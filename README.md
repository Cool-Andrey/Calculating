# Calculating
Сервис подсчёта арифметических выражений

# Перед началом работы 
Требуется Go версии 1.23.1 или выше

Или

Docker версии 27.5.1 или выше

# Запуск

Скопируйте проект через git clone.

## Командная строка

```shell
go mod download
go run cmd/orchestrator/main.go && go run cmd/agent/main.go
```

## Docker CLI

Давайте сначала соберём образы 

```shell
docker build -t orchestrator:latest -f build/orchestrator/Dockerfile & docker build -t agent:latest -f build/agent/Dockerfile
```

Теперь запустим их

Рекомендуется сначала запустить оркестратор

```shell
docker run -d --rm --name orchestrator -p 8080:8080 orchestrator:latest && docker run -d --rm --name agent --link orchestrator:orchestrator -e URL=http://orchestrator:8080 agent:latest
```

Обязательно прокиньте порт через -p! В команде прокидывается порт 8080 на порт сервера 8080. Можете первое число заменить на другой порт. Например, вы хотите прокинуть порт 15. Тогда это будет выглядеть так `15:8080`

Остановить вы можете такой командой
```shell
docker stop agent & docker stop orchestrator
```

## Docker Compose

Самый простой и лучший вариант. Для сборки введите 

```shell
docker compose build 
```
Для запуска
```shell
docker compose up --abort-on-container-failure
```
Для остановки
```shell
docker compose down
```

Либо же можно и для сборки, и для запуска использовать команду
```shell
docker compose up --build --abort-on-container-failure
```
Рекомендую не убирать флаг --abort-on-container-failure. Если один из контейнеров упадёт, то всё остальные тоже упадут за ним. Сделано это в первую очередь для тестов - не прошли тесты, вернули код 1, контейнеры упали. Если что-то не так - опишите в issues вашу проблему, и попробуйте убрать флаг.

# Глобальные переменные
Если вы укажете не то значение, которое здесь описано, то приложение будет падать!!! 
## Логирование
Эти переменные дублируются и для оркестратора, и для агента. Т.е. указывать их надо при запуске каждого.

`MODE_CONSOLE`: режим отображения логов в консоли. Принимает значения `Dev` - более читабельные логи, и `Prod` - вывод в формате json(регистр может быть любым). По умолчанию `Dev`

`MODE_FILE`: режим записи логов в файл. Принимает такие же значения, что и `MODE_CONSOLE`. По умолчанию `Prod`

`CLEAN_FILE`: `false` - файл логов, если не был удалён, не очищать и просто добавлять в конец файла логи. `true` - файл логов, если не был удалён, очищать и заново записывать уже новые логи. По умолчанию `false`

`WRITE_FILE`: определяет, надо ли записывать файл логов. Принимает одно значение - `false` - не записывать. В остальных случаях файл записывается. 

## Задержка
`TIME_ADDITION_MS`: время выполнения сложения(задержка при сложении). В миллисекундах. Принимает любое неотрицательное целое значение. По умолчанию `1000`

`TIME_SUBTRACTION_MS`: время выполнения вычитания(задержка при вычитании). В миллисекундах. Принимает любое неотрицательное целое значение. По умолчанию `1000`

`TIME_MULTIPLICATIONS_MS`: время выполнения умножения(задержка при умножении). В миллисекундах. Принимает любое неотрицательное целое значение. По умолчанию `1000`

`TIME_DIVISIONS_MS`: время выполнения деления(задержка при делении). В миллисекундах. Принимает любое неотрицательное целое значение. По умолчанию `1000`

## Агент

`COMPUTING_POWER`: количество воркеров - горутин, которые выполняют элементарные арифметические операции(+,-,*,/). Принимает любое натуральное значение. По умолчанию `2`

`PING`: раз во сколько миллисекунд будет опрашиваться оркестратор. Принимает любое неотрицательное целое значение. По умолчанию `1000`

`URL`: определяет, на какой адрес будет обращаться транспорт(программа, передающая значение между агентом и оркестратором). Служебная переменная, используется при запуске в docker в связи с особенностями его работы. По умолчанию `http://127.0.0.1:8080`


# Особенности проекта

Данные хранятся в ОЗУ(оперативке) и все данные, которые были , пропадают бесследно

Когда я говорю оркестратор, имеется ввиду и сервер, обрабатывающий запросы пользователя, и оркестратор. В логах оркестратор это та программа, которая создаёт задачи. Она может несколько раз завершаться, хотя сервер ни разу не перезапускали.

Работает проект на RPN и AST.


Ошибки, связанные с форматированием json'а, выводятся сразу при отправке выражения как ответ(примеры ниже). Все ошибки, связанные с корректностью выражения, видны только в результате выражения! Т. е. увидете ошибку вы только запросив результат вычисления выражения.

# Примеры использования 

Тут много примеров, есть файл [postman](examples/postman/Calculatung%20API.postman_collection.json) с более красивым оформлением, ежели это. Для лучшего понимания ознакомьтесь с обоими вариантами - и с README, и с postman коллекцией.

## /api/v1/calculate
Принимает выражение на подсчёт.
### Общий пример запроса/ответа
Внимание! Принимается только POST запрос!

Запрос
```http request
POST http://127.0.0.1:8080/api/v1/calculate
Content-Type: application/json
{
    "expression" : "выражение"
}
```

Код ответа: `201`

Тело ответа
```json
{"id":ваш_id}
```

Если проблема в json

Код ответа `422`

Тело ответа
```json
{"error": "текст ошибки"}
```

Если неправильный метод 

Код ответа `405`

Тело ответа
```
Method Not Allowed
```

### Примеры curl'ов
Внимание! Показаны ответы НА ЭТОТ ЖЕ запрос, а не на GET. 

Правильное выражение
```shell
curl --location 'http://127.0.0.1:8080/api/v1/calculate' \
--header 'Content-Type: application/json' \
--data '{
    "expression" : "2+5/11+65897*989+6582+999*222-88245/2.4"
}'
```
Код ответа `201`.

Тело ответа
```json
{"id":ваш_id}
```

Некорректное выражение
```shell
curl --location 'http://127.0.0.1:8080/api/v1/calculate' \
--header 'Content-Type: application/json' \
--data '{
    "expression": "2+2+"
}'
```
Код ответа `201`.

Тело ответа
```json
{"id":ваш_id}
```

Некорректный json
```shell
curl --location 'http://127.0.0.1:8080/api/v1/calculate' \
--header 'Content-Type: application/json' \
--data '{
    "expression": "2+2"
'
```
Код ответа `422`

Тело ответа
```json
{"error":"Товарищ пользователь! Проверьте правильность написания json'а"}
```

Неправильный метод
```shell
curl --location 'http://127.0.0.1:8080/api/v1/calculate'
```

Код ответа `405`

Тело ответа
```
Method Not Allowed
```

Пустой запрос
```shell
curl --location '' \
--header 'Content-Type: application/json' \
--data ''
```

Код ответа `422`

Тело ответа 
```json
{"error":"Пустой запрос!"}
```

Пустой json

```shell
curl --location 'http://127.0.0.1:8080/api/v1/calculate' \
--header 'Content-Type: application/json' \
--data '{}'
```
Код ответа `201`.

Тело ответа
```json
{"id":ваш_id}
```

Пустое выражение
```shell
curl --location 'http://127.0.0.1:8080/api/v1/calculate' \
--header 'Content-Type: application/json' \
--data '{
    "expression" : ""
}'
```
Код ответа `201`.

Тело ответа
```json
{"id":ваш_id}
```

## api/v1/expressions/{ваш_id}
Ищёт выражение по id
### Общий пример запроса/ответа
Внимание! Принимается только GET запрос!

Запрос
```http request
GET /api/v1/expressions/{Ваш_id} HTTP/1.1
Host: 127.0.0.1:8080
```
Код ответа `200`

Тело ответа
```json
{"expression":{"id":ваш_id,"status":"","result":""}}
```

Если не нашёл выражение код ответа `404` без тела. Произошла внутренняя ошибка - код ответа `500`, опять таки без тела. Если некорректный тип запроса - `405` и текст ```Method Not Allowed```

### Примеры curl'ов
Везде id выражения - 1

Выражение корректно и записано

```shell
curl --location 'http://127.0.0.1:8080/api/v1/expressions/1'
```
Код ответа `200`

Тело ответа, если идёт подсчёт
```json
{"expression":{"id":1,"status":"Подсчёт","result":""}}
```
Если выражение полностью посчиталось
```json
{"expression":{"id":1,"status":"Выполнено","result":"65363726.70"}}
```

Выражение некорректно

```shell
curl --location 'http://127.0.0.1:8080/api/v1/expressions/1'
```

```json
{"expression":{"id":1,"status":"Выполнено","result":"Одна из ошибок записи/вычисления выражения. Подробнее в файле"}} 
``` 
[Ошибки](pkg/calc/errors.go)

## api/v1/expressions
Возвращает массив из json'ов, аналогичных api/v1/expressions/{id}

### Общий пример запроса/ответа
Только GET запросы

```http request
GET /api/v1/expressions HTTP/1.1
Host: 127.0.0.1:8080
```

Код ответа `200`
```json
{"expressions":[{"id":1,"status":"Выполнено","result":"65363726.70"},{"id":2,"status":"Выполнено","result":"Товарищ пользователь! Проверьте количество операндов(+,-,/,*), их порядок и проверьте что нет буков"}]}
```
Либо `500`, если внутренняя ошибка

### Примеры curl'ов

```shell
curl --location 'http://127.0.0.1:8080/api/v1/expressions'
```

Код ответа `200`
```json
{"expressions":[{"id":1,"status":"Выполнено","result":"65363726.70"},{"id":2,"status":"Выполнено","result":"Товарищ пользователь! Проверьте количество операндов(+,-,/,*), их порядок и проверьте что нет буков"}]}
```

## internal/task
Внутренний endpoint сервера для агента
### Общий пример запроса/ответа
GET - получить задачу

```http request
GET /internal/task HTTP/1.1
Host: 127.0.0.1:8080
```

Если нет задачи, ответ `404`

Если есть задача

Код ответа `200`

Тело ответа 
```json
{"task":{"id":ваш_id,"operation":"операция(+,-,*,/)","arg1":первое_число,"arg2":второе_число,"Result":0(нужно для правильного кодирования json),"operation_time":задержка выполнения операции}}
```

POST - отдать задачу

Код ответа `200` - записал, `404` - не нашёл такого выражения, `422` - результат уже есть, `500` - что-то пошло не так

```http request
POST /internal/task HTTP/1.1
Host: 127.0.0.1:8080
Content-Type: application/json
Content-Length: 166

{
    "task":{
        "id":2,
        "operation":"*",
        "arg1":2,
        "arg2":2,
        "Result":4,
        "operation_time":1000000000
    }
}
```

### Примеры curl'ов
GET
```shell
curl --location 'http://127.0.0.1:8080/internal/task'
```

Код ответа либо `404`, без тела

Либо `200`, с примерно таким телом
```json
{"task":{"id":2,"operation":"*","arg1":65897,"arg2":989,"Result":0,"operation_time":1000000000}}
```

POST

```shell
curl --location 'http://127.0.0.1:8080/internal/task' \
--header 'Content-Type: application/json' \
--data '{
    "task":{
        "id":2,
        "operation":"*",
        "arg1":2,
        "arg2":2,
        "Result":4,
        "operation_time":1000000000
    }
}
'
```
Коды ответа указаны выше в описании. Тело ответа всегда пустое.